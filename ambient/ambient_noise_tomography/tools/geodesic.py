# -*- coding: utf-8 -*-
"""
Created on Mon Aug  3 08:50:36 2015

@author: boland
"""

import numpy as np
from math import sqrt, asin, radians, sin, cos
import pyproj
import itertools

# initialise map projection
wgs84 = pyproj.Geod(ellps='WGS84')

class Geodesic:
    """
    Class defined in order to create to process points, distances and
    other related geodesic calculations and functions 
    """    
    
    def __init__(self, period_range=[1, 40], km_point=20., max_dist=2e3):
        # initialise period_range as [1,40] default for ambient noise
        self.per_range = period_range
        self.km = km_point
        self.max_dist = max_dist
        
    def remove_distance(self, period_range, max_dist=None):
        """
        Function that returns a given possible resolvable ambient noise
        structure distance range, given the maximum period range
        availabe to the study. The distance returned is in km.
        
        Maximum distance default can be reassigned based on the cut-off found
        by your time-lag plots for your study! 
        """
        if max_dist is None: 
            max_dist = self.max_dist
        
        if type(period_range) == list:
            min_dist = min(period_range) * 9
            return [min_dist, max_dist]
        
        elif type(period_range) == int or float:
            return [period_range*9, max_dist]

    def haversine(self, lon1, lat1, lon2, lat2, R=6371):
        """
        Calculate the great circle distance between two points 
        on the earth (specified in decimal degrees). R is radius of
        spherical earth. Default is 6371km.
        """
        # convert decimal degrees to radians 
        lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
        # haversine formula 
        dlon, dlat = lon2 - lon1, lat2 - lat1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * asin(sqrt(a)) 
        km = R * c
        return km

    def fast_geodesic(self, lon1, lat1, lon2, lat2, npts):
        """
        Returns a list of *npts* points along the geodesic between
        (and including) *coord1* and *coord2*, in an array of
        shape (*npts*, 2).
        @rtype: L{ndarray}
        """
        if npts < 2:
            raise Exception('nb of points must be at least 2')

        path = wgs84.npts(lon1=lon1, lat1=lat1,
                          lon2=lon2, lat2=lat2,
                          npts=npts-2)
                      
        return np.array([[lon1,lat1]] + path + [[lon2,lat2]])

    def paths_calc(self, path_info, km_points=None, per_lims=None):
        """
        Function that returns an array of coordinates equidistant along 
        a great cricle path between two lat-lon coordinates if these points
        lay within a certain distance range ... otherwise the points return
        only a set of zeros the same size as the array. Default is 1.0km 
        distance per point.
        """
        if per_lims is None:
            # if no new default for period limits is defined, then set the
            # limit to the default.
            per_lims = self.per_range
            
        if km_points is None: 
            km_points = self.km
        
        lon1, lat1, lon2, lat2 = path_info[0], \
        path_info[1], path_info[2], path_info[3]    
        
        # interpoint distance <= 1 km, and nb of points >= 100
        dist = self.haversine(lon1, lat1, lon2, lat2)    
        npts = max(int((np.ceil(dist) + 1) / km_points), 100)    
        path = self.fast_geodesic(lon1, lat1, lon2, lat2, npts)
        dist_range = self.remove_distance(per_lims)
        
        if min(dist_range) < dist < max(dist_range):
        #remove the closest points along this line that fall below the distance 
        #find the index of the first point that is above this distance away!
            pts_km = npts / float((np.ceil(dist) + 1)) #this gives pts/km
            #remove all points below this index in the paths list
            dist_index = pts_km * min(dist_range) 
            path = path[dist_index:]
            return path    
        else:
            return np.zeros_like(path)
        
    def fast_paths(self, coord_list):
        """
        Function that takes many point coordinate combinations and quickly
        passes them through the paths_calc function. coord_list MUST be
        of the shape (4, N) whereby each coordinate combination is in a 
        (4,1) row [lon1,lat1,lon2,lat2]. 
        """
        return map(self.paths_calc, coord_list)
        
    def combine_paths(self, paths):
        """
        Function that takes many paths (should be array of same length as 
        number of stations). This is automatically generated by parallelising
        the fast_paths function above. 
        
        The output array should only contain unique, no repeating paths 
        and should be of the shape (2,N) where N is a large number of coords.
        """
        
        #create a flattened numpy array of size 2xN from the paths created! 
        paths = list(itertools.chain(*paths))
        paths = np.asarray(list(itertools.chain\
                                    (*paths)))
    
        #keep all but the repeated coordinates by keeping only unique whole rows!
        b = np.ascontiguousarray(paths).view(np.dtype\
        ((np.void, paths.dtype.itemsize * \
        paths.shape[1])))
        _, idx = np.unique(b, return_index=True)
        
        paths = np.unique(b).view(paths.dtype)\
        .reshape(-1, paths.shape[1])
        
        return paths
        
    def remove_zeros(self, paths):
        """
        Function that processes the flattened path output from combine_paths
        and removes the zero paths created by paths_calc. Remove zeroes 
        from paths to ensure all paths that were NOT in the distance threshold 
        are removed from the path density calculation! 
        """
    
        path_lons, path_lats = paths[:,0], paths[:,1]
                                               
        FIND_ZERO1 = np.where(paths[:,0]==0)[0]
        FIND_ZERO2 = np.where(paths[:,1]==0)[0]
        if len(FIND_ZERO1) != 0 and len(FIND_ZERO2) != 0:
            path_lons = np.delete(path_lons, FIND_ZERO1)
            path_lats = np.delete(path_lats, FIND_ZERO2)
        
        return np.column_stack((path_lons, path_lats))